#file: ma_bot.py

import asyncio
import json
import os
import aiohttp
import hmac
import hashlib
import urllib.parse
import time
from datetime import datetime
from telegram import (
    ReplyKeyboardMarkup,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
    Update
)
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
    ContextTypes,
    Application
)
from config import TOKEN, CHAT_ID, BINANCE_API_KEY, BINANCE_API_SECRET

# Êñá‰ª∂Ë∑ØÂæÑ
DATA_FILE = "symbols.json"
TRADE_SETTINGS_FILE = "trade_settings.json"
EXISTING_POSITIONS_FILE = "existing_positions.json"

# KÁ∫øÂèÇÊï∞
INTERVAL = "15m"

# ‰∏ªËèúÂçï
main_menu = [
    ["1. Ê∑ªÂä†Â∏ÅÁßç", "2. Âà†Èô§Â∏ÅÁßç"],
    ["3. ÂºÄÂêØÁõëÊéß", "4. ÂÅúÊ≠¢ÁõëÊéß"],
    ["5. ÂºÄÂêØËá™Âä®‰∫§Êòì", "6. ÂÖ≥Èó≠Ëá™Âä®‰∫§Êòì"],
    ["7. Êü•ÁúãÁä∂ÊÄÅ", "8. Â∏ÆÂä©"]
]
reply_markup_main = ReplyKeyboardMarkup(main_menu, resize_keyboard=True)

# --- Êó∂Èó¥ÂêåÊ≠•Ê®°Âùó ---
class TimeSync:
    _instance = None
    _time_diff = 0
    _last_sync = 0
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    async def sync_time(self):
        try:
            # ‰ΩøÁî®ÂêàÁ∫¶APIËøõË°åÊó∂Èó¥ÂêåÊ≠•
            url = "https://fapi.binance.com/fapi/v1/time"
            async with aiohttp.ClientSession() as session:
                async with session.get(url) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        server_time = data["serverTime"]
                        local_time = int(time.time() * 1000)
                        self._time_diff = server_time - local_time
                        self._last_sync = time.time()
                        print(f"Êó∂Èó¥ÂêåÊ≠•ÊàêÂäüÔºåÊó∂Èó¥Â∑Æ: {self._time_diff}ms")
                    else:
                        error = await resp.text()
                        print(f"Êó∂Èó¥ÂêåÊ≠•Â§±Ë¥• ({resp.status}): {error}")
        except Exception as e:
            print(f"Êó∂Èó¥ÂêåÊ≠•ÂºÇÂ∏∏: {e}")
    
    def get_corrected_time(self):
        # Â¶ÇÊûúË∂ÖËøá10ÂàÜÈíüÊú™ÂêåÊ≠•ÔºåÂàôÈáçÊñ∞ÂêåÊ≠•
        if time.time() - self._last_sync > 600:
            asyncio.create_task(self.sync_time())
        return int(time.time() * 1000) + self._time_diff

time_sync = TimeSync()

# --- ÂàùÂßãÂåñ ---
def load_data():
    if os.path.exists(DATA_FILE):
        with open(DATA_FILE, "r") as f:
            try:
                return json.load(f)
            except:
                return {"symbols": [], "monitor": False}
    return {"symbols": [], "monitor": False}

def load_trade_settings():
    default_settings = {
        "auto_trade": False, 
        "setting_mode": "global",  # global or individual
        "global_leverage": 10,
        "global_order_amount": 100,
        "individual_settings": {},
        "take_profit": 0,
        "stop_loss": 0
    }
    if os.path.exists(TRADE_SETTINGS_FILE):
        with open(TRADE_SETTINGS_FILE, "r") as f:
            try:
                loaded = json.load(f)
                for key in default_settings:
                    if key not in loaded:
                        loaded[key] = default_settings[key]
                return loaded
            except:
                return default_settings
    return default_settings

def load_existing_positions():
    if os.path.exists(EXISTING_POSITIONS_FILE):
        with open(EXISTING_POSITIONS_FILE, "r") as f:
            try:
                return json.load(f)
            except:
                return {}
    return {}

def save_existing_positions(positions):
    with open(EXISTING_POSITIONS_FILE, "w") as f:
        json.dump(positions, f)

def save_trade_settings(settings):
    with open(TRADE_SETTINGS_FILE, "w") as f:
        json.dump(settings, f)

data = load_data()
trade_settings = load_trade_settings()
existing_positions = load_existing_positions()
monitoring_task = None
user_states = {}
prev_klines = {}
positions = {}
oco_orders = {}

# --- Binance API Â¢ûÂº∫Áâà ---
async def binance_request(method, endpoint, params=None, signed=False, retry=3):
    url = f"https://fapi.binance.com{endpoint}"
    headers = {"X-MBX-APIKEY": BINANCE_API_KEY} if signed else {}
    
    for attempt in range(retry):
        try:
            if signed:
                params = params or {}
                params["timestamp"] = time_sync.get_corrected_time()
                params["recvWindow"] = 5000
                params["signature"] = generate_signature(params)
            
            async with aiohttp.ClientSession() as session:
                async with session.request(method, url, params=params, headers=headers) as resp:
                    if resp.status == 200:
                        return await resp.json()
                    else:
                        error = await resp.text()
                        print(f"Binance API ÈîôËØØ ({resp.status}): {error}")
                        if "timestamp" in error.lower() and attempt < retry - 1:
                            await time_sync.sync_time()  # Êó∂Èó¥‰∏çÂêåÊ≠•Êó∂Á´ãÂç≥ÈáçËØï
                            continue
                        return None
        except Exception as e:
            print(f"ËØ∑Ê±ÇÂºÇÂ∏∏: {e}")
            if attempt == retry - 1:
                return None
            await asyncio.sleep(1)
    
    return None

def generate_signature(params):
    query = urllib.parse.urlencode(params)
    return hmac.new(
        BINANCE_API_SECRET.encode('utf-8'),
        query.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()

# --- Ëé∑ÂèñKÁ∫øÊï∞ÊçÆÂáΩÊï∞ ---
async def get_klines(symbol, market_type, interval=INTERVAL, limit=100):
    """Ëé∑ÂèñKÁ∫øÊï∞ÊçÆ"""
    if market_type == "contract":
        endpoint = "/fapi/v1/klines"
    else:
        # Áé∞Ë¥ß‰ΩøÁî®‰∏çÂêåÁ´ØÁÇπ
        endpoint = "/api/v3/klines"
    
    params = {
        "symbol": symbol,
        "interval": interval,
        "limit": limit
    }
    return await binance_request("GET", endpoint, params)

# --- Ëé∑ÂèñÊåÅ‰ªì‰ø°ÊÅØÂáΩÊï∞ ---
async def get_position(symbol):
    """Ëé∑ÂèñÊåáÂÆöÂ∏ÅÁßçÁöÑÊåÅ‰ªì‰ø°ÊÅØ"""
    positions_data = await binance_request("GET", "/fapi/v2/positionRisk", None, True)
    if positions_data:
        for pos in positions_data:
            if pos["symbol"] == symbol and float(pos["positionAmt"]) != 0:
                return {
                    "symbol": symbol,
                    "side": "LONG" if float(pos["positionAmt"]) > 0 else "SHORT",
                    "qty": abs(float(pos["positionAmt"])),
                    "entry_price": float(pos["entryPrice"]),
                    "leverage": int(pos["leverage"]),
                    "unrealized_profit": float(pos["unRealizedProfit"]),
                    "mark_price": float(pos["markPrice"])
                }
    return None

# --- ‰∫§ÊòìÂäüËÉΩ ---
async def set_leverage(symbol, leverage):
    return await binance_request("POST", "/fapi/v1/leverage", 
                               {"symbol": symbol, "leverage": leverage}, True)

async def place_market_order(symbol, side, quantity):
    params = {
        "symbol": symbol,
        "side": side,
        "type": "MARKET",
        "quantity": round(quantity, 3)
    }
    return await binance_request("POST", "/fapi/v1/order", params, True)

async def place_oco_order(symbol, side, quantity, entry_price, take_profit, stop_loss):
    if take_profit <= 0 and stop_loss <= 0:
        return None
    
    if side == "BUY":
        take_profit_price = entry_price * (1 + take_profit / 100)
        stop_loss_price = entry_price * (1 - stop_loss / 100)
        oco_side = "SELL"
    else:
        take_profit_price = entry_price * (1 - take_profit / 100)
        stop_loss_price = entry_price * (1 + stop_loss / 100)
        oco_side = "BUY"
    
    params = {
        "symbol": symbol,
        "side": oco_side,
        "quantity": round(quantity, 3),
        "price": round(take_profit_price, 4),
        "stopPrice": round(stop_loss_price, 4),
        "stopLimitPrice": round(stop_loss_price, 4),
        "stopLimitTimeInForce": "GTC"
    }
    return await binance_request("POST", "/fapi/v1/order/oco", params, True)

# --- MAËÆ°ÁÆó ---
def calculate_ma(klines):
    """ËÆ°ÁÆóMA9ÂíåMA26ÊåáÊ†á"""
    if not klines or len(klines) < 26:
        return 0, 0, 0
        
    closes = [float(k[4]) for k in klines]
    ma9 = sum(closes[-9:]) / 9
    ma26 = sum(closes[-26:]) / 26
    return ma9, ma26, closes[-1]

# --- ÁõëÊéß‰ªªÂä° ---
async def monitor_task(app):
    print("ÁõëÊéß‰ªªÂä°ÂêØÂä®")
    await time_sync.sync_time()
    prev_states = {}
    
    try:
        while data["monitor"]:
            print(f"ÁõëÊéßÂæ™ÁéØÂºÄÂßã - ÁõëÊéßÂ∏ÅÁßçÊï∞Èáè: {len(data['symbols'])}")
            for item in data["symbols"]:
                symbol = item["symbol"]
                symbol_key = f"{symbol}_{item['type']}"
                try:
                    klines = await get_klines(symbol, item["type"])
                    if not klines or len(klines) < 26:
                        print(f"Ëé∑ÂèñKÁ∫øÂ§±Ë¥•ÊàñÊï∞ÊçÆ‰∏çË∂≥: {symbol}")
                        continue
                    
                    if symbol_key in prev_klines and klines[-1][0] == prev_klines[symbol_key][-1][0]:
                        continue
                    
                    prev_klines[symbol_key] = klines
                    ma9, ma26, price = calculate_ma(klines)
                    
                    if symbol_key in prev_states:
                        prev_ma9, prev_ma26 = prev_states[symbol_key]
                        
                        # ‰ø°Âè∑Ê£ÄÊµã
                        if prev_ma9 <= prev_ma26 and ma9 > ma26:
                            signal_msg = f"üìà Ê£ÄÊµãÂà∞‰π∞ÂÖ•‰ø°Âè∑ {symbol}\n‰ª∑Ê†º: {price:.4f}"
                            print(signal_msg)
                            for uid in user_states.keys():
                                await app.bot.send_message(chat_id=uid, text=signal_msg)
                            
                            if item["type"] == "contract" and trade_settings["auto_trade"]:
                                if await execute_trade(app, symbol, "BUY"):
                                    pass
                        
                        elif prev_ma9 >= prev_ma26 and ma9 < ma26:
                            signal_msg = f"üìâ Ê£ÄÊµãÂà∞ÂçñÂá∫‰ø°Âè∑ {symbol}\n‰ª∑Ê†º: {price:.4f}"
                            print(signal_msg)
                            for uid in user_states.keys():
                                await app.bot.send_message(chat_id=uid, text=signal_msg)
                            
                            if item["type"] == "contract" and trade_settings["auto_trade"]:
                                if await execute_trade(app, symbol, "SELL"):
                                    pass
                    
                    prev_states[symbol_key] = (ma9, ma26)
                    
                    # Ê≠¢ÁõàÊ≠¢ÊçüÊ£ÄÊü•ÔºàÂåÖÊã¨Â∑≤ÊúâÊåÅ‰ªìÔºâ
                    if item["type"] == "contract":
                        # Ê£ÄÊü•Êú¨Á≥ªÁªüÊñ∞ÂºÄÁöÑÊåÅ‰ªì
                        if symbol in positions:
                            pos = positions[symbol]
                            await check_tp_sl(app, symbol, pos, price)
                        
                        # Ê£ÄÊü•Â∑≤ÊúâÊåÅ‰ªìÔºàÂºÄÂêØËá™Âä®‰∫§ÊòìÊó∂‰øùÁïôÁöÑÔºâ
                        if symbol in existing_positions and existing_positions[symbol]["active"]:
                            pos = existing_positions[symbol]
                            await check_tp_sl(app, symbol, pos, price)
                
                except Exception as e:
                    print(f"ÁõëÊéß {symbol} Âá∫Èîô: {e}")
            
            print("ÁõëÊéßÂæ™ÁéØÂÆåÊàêÔºåÁ≠âÂæÖ60Áßí...")
            await asyncio.sleep(60)
    except asyncio.CancelledError:
        print("ÁõëÊéß‰ªªÂä°Ë¢´ÂèñÊ∂à")
    except Exception as e:
        print(f"ÁõëÊéß‰ªªÂä°ÂºÇÂ∏∏: {e}")

# Ê£ÄÊü•Ê≠¢ÁõàÊ≠¢ÊçüÈÄöÁî®ÂáΩÊï∞
async def check_tp_sl(app, symbol, pos, price):
    """Ê£ÄÊü•Ê≠¢ÁõàÊ≠¢ÊçüÂπ∂ÊâßË°åÂπ≥‰ªì"""
    entry_price = pos["entry_price"]
    
    if pos["side"] == "LONG":
        take_profit_price = entry_price * (1 + trade_settings["take_profit"] / 100)
        stop_loss_price = entry_price * (1 - trade_settings["stop_loss"] / 100)
    else:
        take_profit_price = entry_price * (1 - trade_settings["take_profit"] / 100)
        stop_loss_price = entry_price * (1 + trade_settings["stop_loss"] / 100)
    
    if trade_settings["take_profit"] > 0:
        if (pos["side"] == "LONG" and price >= take_profit_price) or \
           (pos["side"] == "SHORT" and price <= take_profit_price):
            for uid in user_states.keys():
                await app.bot.send_message(chat_id=uid, text=f"üìà Ê£ÄÊµãÂà∞{symbol}Ê≠¢ÁõàËß¶Âèë")
            await close_position(app, symbol, "take_profit", price, is_existing=(symbol in existing_positions))
    
    if trade_settings["stop_loss"] > 0:
        if (pos["side"] == "LONG" and price <= stop_loss_price) or \
           (pos["side"] == "SHORT" and price >= stop_loss_price):
            for uid in user_states.keys():
                await app.bot.send_message(chat_id=uid, text=f"üìâ Ê£ÄÊµãÂà∞{symbol}Ê≠¢ÊçüËß¶Âèë")
            await close_position(app, symbol, "stop_loss", price, is_existing=(symbol in existing_positions))

# --- execute_trade ÂáΩÊï∞ÔºàÂ∑≤‰øÆÂ§çÂêç‰πâ‰ª∑ÂÄºÈóÆÈ¢òÔºâ---
async def execute_trade(app, symbol, signal_type):
    if not trade_settings["auto_trade"]:
        return False
    
    try:
        # Ëé∑ÂèñËÆæÁΩÆ
        leverage = trade_settings["global_leverage"]
        notional_value = trade_settings["global_order_amount"]  # Áî®Êà∑ËÆæÁΩÆÁöÑÂêç‰πâ‰ª∑ÂÄº
        
        # Ê£ÄÊü•ÊòØÂê¶ÊúâÂ∏ÅÁßçÁâπÂÆöËÆæÁΩÆ
        if trade_settings["setting_mode"] == "individual":
            symbol_settings = trade_settings["individual_settings"].get(symbol)
            if symbol_settings:
                leverage = symbol_settings.get("leverage", leverage)
                notional_value = symbol_settings.get("order_amount", notional_value)
        
        # Á°Æ‰øùÂêç‰πâ‰ª∑ÂÄºËá≥Â∞ë‰∏∫20 USDT
        if notional_value < 20:
            notional_value = 20
        
        # ËÆæÁΩÆÊù†ÊùÜ
        leverage_resp = await set_leverage(symbol, leverage)
        if leverage_resp is None:
            for uid in user_states.keys():
                await app.bot.send_message(chat_id=uid, text=f"‚ùå {symbol} ËÆæÁΩÆÊù†ÊùÜÂ§±Ë¥•")
            return False
        
        # Ëé∑ÂèñKÁ∫øÊï∞ÊçÆ
        klines = await get_klines(symbol, "contract")
        if not klines:
            for uid in user_states.keys():
                await app.bot.send_message(chat_id=uid, text=f"‚ùå {symbol} Ëé∑ÂèñKÁ∫øÂ§±Ë¥•")
            return False
            
        price = float(klines[-1][4])
        
        # ËÆ°ÁÆó‰øùËØÅÈáë
        margin = notional_value / leverage
        
        # ËÆ°ÁÆóÊï∞Èáè
        quantity = notional_value / price
        quantity = round(quantity, 3)  # ÂõõËàç‰∫îÂÖ•Âà∞3‰ΩçÂ∞èÊï∞
        
        # Â§ÑÁêÜÂèçÂêëÊåÅ‰ªì
        if signal_type == "BUY":
            pos = await get_position(symbol)
            if pos and pos["side"] == "SHORT":
                for uid in user_states.keys():
                    await app.bot.send_message(chat_id=uid, text=f"‚ö†Ô∏è Ê£ÄÊµãÂà∞‰π∞ÂÖ•‰ø°Âè∑ÔºåÊ≠£Âú®Âπ≥Á©∫‰ªì {symbol}")
                await close_position(app, symbol)
            
            for uid in user_states.keys():
                await app.bot.send_message(chat_id=uid, text=f"üöÄ Ê≠£Âú®ÂºÄÂ§ö‰ªì {symbol}...")
                
            order = await place_market_order(symbol, "BUY", quantity)
            
        elif signal_type == "SELL":
            pos = await get_position(symbol)
            if pos and pos["side"] == "LONG":
                for uid in user_states.keys():
                    await app.bot.send_message(chat_id=uid, text=f"‚ö†Ô∏è Ê£ÄÊµãÂà∞ÂçñÂá∫‰ø°Âè∑ÔºåÊ≠£Âú®Âπ≥Â§ö‰ªì {symbol}")
                await close_position(app, symbol)
            
            for uid in user_states.keys():
                await app.bot.send_message(chat_id=uid, text=f"üöÄ Ê≠£Âú®ÂºÄÁ©∫‰ªì {symbol}...")
                
            order = await place_market_order(symbol, "SELL", quantity)
        
        # Â§ÑÁêÜËÆ¢ÂçïÁªìÊûú
        if order:
            entry_price = float(order.get('price', price))
            positions[symbol] = {
                "side": "LONG" if signal_type == "BUY" else "SHORT",
                "qty": quantity,
                "entry_price": entry_price,
                "system_order": True  # Ê†áËÆ∞‰∏∫Êú¨Á≥ªÁªüËÆ¢Âçï
            }
            
            # ÂèëÈÄÅÈÄöÁü•
            pos_type = "Â§ö‰ªì" if signal_type == "BUY" else "Á©∫‰ªì"
            msg = f"‚úÖ ÂºÄ‰ªìÊàêÂäü {symbol} {pos_type}\n" \
                  f"‰ª∑Ê†º: {entry_price:.4f}\n" \
                  f"Êï∞Èáè: {quantity:.4f}\n" \
                  f"Êù†ÊùÜ: {leverage}x\n" \
                  f"Âêç‰πâ‰ª∑ÂÄº: {notional_value:.2f} USDT\n" \
                  f"‰øùËØÅÈáë: {margin:.2f} USDT"
            for uid in user_states.keys():
                await app.bot.send_message(chat_id=uid, text=msg)
            
            # ËÆæÁΩÆÊ≠¢ÁõàÊ≠¢Êçü
            if trade_settings["take_profit"] > 0 or trade_settings["stop_loss"] > 0:
                oco_order = await place_oco_order(
                    symbol, 
                    signal_type, 
                    quantity, 
                    entry_price, 
                    trade_settings["take_profit"], 
                    trade_settings["stop_loss"]
                )
                if oco_order:
                    oco_orders[symbol] = oco_order
            return True
        else:
            for uid in user_states.keys():
                await app.bot.send_message(chat_id=uid, text=f"‚ùå {symbol} ‰∏ãÂçïÂ§±Ë¥•")
            return False
            
    except Exception as e:
        for uid in user_states.keys():
            await app.bot.send_message(chat_id=uid, text=f"‚ùå {symbol} ‰∫§ÊòìÂá∫Èîô: {str(e)}")
        return False

# --- close_position ÂáΩÊï∞ ---
async def close_position(app, symbol, close_type="signal", close_price=None, is_existing=False):
    try:
        pos = await get_position(symbol)
        if not pos:
            for uid in user_states.keys():
                await app.bot.send_message(chat_id=uid, text=f"‚ö†Ô∏è {symbol} Êó†ÊåÅ‰ªìÂèØÂπ≥")
            return False
        
        # ÂèëÈÄÅÂπ≥‰ªìÈÄöÁü•
        pos_type = "Â§ö‰ªì" if pos["side"] == "LONG" else "Á©∫‰ªì"
        for uid in user_states.keys():
            await app.bot.send_message(chat_id=uid, text=f"üõë Ê≠£Âú®Âπ≥{symbol}{pos_type}...")
        
        # ÊâßË°åÂπ≥‰ªì
        side = "SELL" if pos["side"] == "LONG" else "BUY"
        result = await place_market_order(symbol, side, pos["qty"])
        
        if not result:
            for uid in user_states.keys():
                await app.bot.send_message(chat_id=uid, text=f"‚ùå {symbol} Âπ≥‰ªìÂ§±Ë¥•")
            return False
        
        # ËÆ°ÁÆóÁõà‰∫è
        if close_price is None:
            klines = await get_klines(symbol, "contract")
            close_price = float(klines[-1][4]) if klines else pos["entry_price"]
        
        entry = pos["entry_price"]
        profit = (close_price - entry) * pos["qty"] if pos["side"] == "LONG" else (entry - close_price) * pos["qty"]
        profit_percent = abs(profit / (entry * pos["qty"])) * 100
        profit_sign = "+" if profit > 0 else ""
        
        # ÂèëÈÄÅÂπ≥‰ªìÁªìÊûú
        close_reason = {
            "take_profit": "Ê≠¢Áõà",
            "stop_loss": "Ê≠¢Êçü",
            "signal": "‰ø°Âè∑"
        }.get(close_type, "ÊâãÂä®")
        
        msg = f"üìå {symbol} Âπ≥‰ªìÂÆåÊàê ({close_reason})\n" \
              f"Á±ªÂûã: {pos_type}\n" \
              f"Êï∞Èáè: {pos['qty']:.4f}\n" \
              f"ÂºÄ‰ªì‰ª∑: {entry:.4f}\n" \
              f"Âπ≥‰ªì‰ª∑: {close_price:.4f}\n" \
              f"Áõà‰∫è: {profit_sign}{profit:.2f} ({profit_sign}{profit_percent:.2f}%)"
        
        for uid in user_states.keys():
            await app.bot.send_message(chat_id=uid, text=msg)
        
        # Ê∏ÖÁêÜËÆ∞ÂΩï
        if symbol in positions:
            del positions[symbol]
        if symbol in oco_orders:
            del oco_orders[symbol]
        if is_existing and symbol in existing_positions:
            existing_positions[symbol]["active"] = False
            save_existing_positions(existing_positions)
            
        return True
        
    except Exception as e:
        for uid in user_states.keys():
            await app.bot.send_message(chat_id=uid, text=f"‚ùå {symbol} Âπ≥‰ªìÂá∫Èîô: {str(e)}")
        return False

# --- ËÆ°ÁÆóÊåÅ‰ªìÁõà‰∫è ---
async def calculate_position_profit(symbol, entry_price, side, qty):
    try:
        klines = await get_klines(symbol, "contract")
        if not klines:
            return 0, 0
        
        current_price = float(klines[-1][4])
        if side == "LONG":
            profit = (current_price - entry_price) * qty
            profit_percent = (current_price - entry_price) / entry_price * 100
        else:
            profit = (entry_price - current_price) * qty
            profit_percent = (entry_price - current_price) / entry_price * 100
        
        return profit, profit_percent
    except:
        return 0, 0

# --- Ê£ÄÊµãÈùûÁ≥ªÁªüËÆ¢Âçï ---
async def check_existing_positions(app, user_id):
    """Ê£ÄÊµãÈùûÁ≥ªÁªüËÆ¢ÂçïÂπ∂ËøîÂõûÂ§ÑÁêÜÁªìÊûú"""
    positions_data = await binance_request("GET", "/fapi/v2/positionRisk", None, True)
    existing_pos = {}
    if positions_data:
        for pos in positions_data:
            position_amt = float(pos["positionAmt"])
            if position_amt != 0:
                symbol = pos["symbol"]
                existing_pos[symbol] = {
                    "side": "LONG" if position_amt > 0 else "SHORT",
                    "qty": abs(position_amt),
                    "entry_price": float(pos["entryPrice"]),
                    "active": False,
                    "system_order": False
                }
    
    if not existing_pos:
        return None
    
    # ‰øùÂ≠òÂ∑≤ÊúâÊåÅ‰ªì‰ø°ÊÅØ
    existing_positions.clear()
    existing_positions.update(existing_pos)
    save_existing_positions(existing_positions)
    
    # ÊòæÁ§∫ÊåÅ‰ªìËØ¶ÊÉÖÂπ∂ÂºïÂØºÁî®Êà∑ÈÄâÊã©
    msg = "‚ö†Ô∏è Ê£ÄÊµãÂà∞ÈùûÊú¨Á≥ªÁªüÊåÅ‰ªì:\n"
    for symbol, pos in existing_positions.items():
        # ËÆ°ÁÆóÁõà‰∫è
        profit, profit_percent = await calculate_position_profit(
            symbol, 
            pos["entry_price"], 
            pos["side"], 
            pos["qty"]
        )
        profit_sign = "+" if profit > 0 else ""
        pos_type = "Â§ö‰ªì" if pos["side"] == "LONG" else "Á©∫‰ªì"
        msg += (f"\nüìä {symbol} {pos_type}\n"
                f"Êï∞Èáè: {pos['qty']:.4f}\n"
                f"ÂºÄ‰ªì‰ª∑: {pos['entry_price']:.4f}\n"
                f"Áõà‰∫è: {profit_sign}{profit:.2f} ({profit_sign}{profit_percent:.2f}%)\n")
    
    msg += "\nÊòØÂê¶Â∞ÜËøô‰∫õÊåÅ‰ªìÁ∫≥ÂÖ•Êú¨Á≥ªÁªüÁÆ°ÁêÜÔºü"
    
    keyboard = [
        [
            InlineKeyboardButton("ÊòØÔºåÂÖ®ÈÉ®Á∫≥ÂÖ•", callback_data="integrate_existing:all"),
            InlineKeyboardButton("Âê¶Ôºå‰øùÁïôÂéüÁä∂", callback_data="integrate_existing:none")
        ],
        [InlineKeyboardButton("ÈÄâÊã©ÈÉ®ÂàÜÁ∫≥ÂÖ•", callback_data="integrate_existing:select")]
    ]
    
    return {"message": msg, "keyboard": keyboard}

# --- ÊòæÁ§∫Ëá™Âä®‰∫§ÊòìËÆæÁΩÆ ---
async def show_auto_trade_settings(app, user_id):
    setting_info = "‚úÖ Ëá™Âä®‰∫§ÊòìÂ∑≤ÂºÄÂêØÔºÅ\n"
    
    if trade_settings["setting_mode"] == "global":
        setting_info += f"ÂÖ®Â±ÄËÆæÁΩÆ:\n" \
                       f"Êù†ÊùÜ: {trade_settings['global_leverage']}x\n" \
                       f"‰∏ãÂçïÈáëÈ¢ù: {trade_settings['global_order_amount']} USDT\n"
    else:
        setting_info += "ÈÄê‰∏ÄËÆæÁΩÆ:\n"
        for symbol, settings in trade_settings["individual_settings"].items():
            leverage = settings.get("leverage", trade_settings["global_leverage"])
            order_amount = settings.get("order_amount", trade_settings["global_order_amount"])
            setting_info += f"{symbol} Êù†ÊùÜ: {leverage}x  ‰∏ãÂçïÈáëÈ¢ù: {order_amount}USDT\n"
    
    setting_info += f"Ê≠¢Áõà: {trade_settings['take_profit']}%\n" \
                   f"Ê≠¢Êçü: {trade_settings['stop_loss']}%"
    
    # Â¶ÇÊûúÊúâÁ∫≥ÂÖ•ÁöÑÈùûÊú¨Á≥ªÁªüÊåÅ‰ªìÔºå‰πüÊòæÁ§∫Âá∫Êù•
    if existing_positions:
        setting_info += "\n\nÂ∑≤Á∫≥ÂÖ•ÁöÑÈùûÊú¨Á≥ªÁªüÊåÅ‰ªìÔºö\n"
        for symbol, pos in existing_positions.items():
            if pos.get("system_order", False) and pos.get("active", False):
                pos_type = "Â§ö‰ªì" if pos["side"] == "LONG" else "Á©∫‰ªì"
                setting_info += f"{symbol} {pos_type} Êï∞Èáè: {pos['qty']:.4f}\n"
    
    await app.bot.send_message(user_id, setting_info)
    await app.bot.send_message(user_id, "ËØ∑‰ΩøÁî®‰∏ãÊñπËèúÂçïÁªßÁª≠Êìç‰ΩúÔºö", reply_markup=reply_markup_main)
    
    # Á°Æ‰øùÊ∏ÖÈô§Áî®Êà∑Áä∂ÊÄÅ
    if user_id in user_states:
        del user_states[user_id]

# --- handle_auto_trade ÂáΩÊï∞Ôºà‰ºòÂåñÊµÅÁ®ãÔºâ---
async def handle_auto_trade(update, context, enable):
    app = context.application
    user_id = update.effective_chat.id
    
    if enable:
        # ‰ΩøÁî®ÁÆÄÂçïÁöÑAPIË∞ÉÁî®È™åËØÅËøûÊé•
        ping_response = await binance_request("GET", "/fapi/v1/ping")
        if ping_response is None:
            await update.message.reply_text(
                "‚ùå Êó†Ê≥ïËøûÊé•Â∏ÅÂÆâAPIÔºåËØ∑Ê£ÄÊü•APIÂØÜÈí•ÂíåÁΩëÁªúËøûÊé•",
                reply_markup=reply_markup_main
            )
            return
        
        # Áõ¥Êé•ÊòæÁ§∫ËÆæÁΩÆÈÄâÈ°πÔºå‰∏çÂÜçËØ¢ÈóÆ
        keyboard = [
            [
                InlineKeyboardButton("ÂÖ®Â±ÄËÆæÁΩÆ", callback_data="auto_trade_setting:global"),
                InlineKeyboardButton("ÈÄê‰∏ÄËÆæÁΩÆ", callback_data="auto_trade_setting:individual")
            ]
        ]
        await update.message.reply_text(
            "‚úÖ APIÈ™åËØÅÊàêÂäü",
            reply_markup=InlineKeyboardMarkup(keyboard))
    else:
        trade_settings["auto_trade"] = False
        save_trade_settings(trade_settings)
        
        # Ëé∑ÂèñËØ¶ÁªÜÁöÑÊåÅ‰ªì‰ø°ÊÅØ
        positions_data = await binance_request("GET", "/fapi/v2/positionRisk", None, True)
        msg = "Ëá™Âä®‰∫§ÊòìÂ∑≤ÂÖ≥Èó≠\n"
        
        if positions_data:
            for pos in positions_data:
                position_amt = float(pos["positionAmt"])
                if position_amt != 0:
                    symbol = pos["symbol"]
                    pos_type = "Â§ö‰ªì" if position_amt > 0 else "Á©∫‰ªì"
                    entry_price = float(pos["entryPrice"])
                    mark_price = float(pos["markPrice"])
                    leverage = pos["leverage"]
                    unrealized_profit = float(pos["unRealizedProfit"])
                    
                    msg += (f"\nÊåÅ‰ªì: {symbol} {pos_type} x{leverage}\n"
                            f"Êï∞Èáè: {abs(position_amt)}\n"
                            f"ÂºÄ‰ªì‰ª∑: {entry_price:.4f}\n"
                            f"ÂΩìÂâçÊ†áËÆ∞‰ª∑: {mark_price:.4f}\n"
                            f"Êú™ÂÆûÁé∞Áõà‰∫è: {unrealized_profit:.4f} USDT\n")
        
        if "ÊåÅ‰ªì:" in msg:
            keyboard = [
                [InlineKeyboardButton("Ê∏Ö‰ªìÊâÄÊúâÊåÅ‰ªì", callback_data="close_all:yes")],
                [InlineKeyboardButton("‰øùÁïôÊåÅ‰ªì", callback_data="close_all:no")]
            ]
            await update.message.reply_text(
                msg + "\nÊòØÂê¶Ê∏ÖÁ©∫ÊâÄÊúâÊåÅ‰ªì?",
                reply_markup=InlineKeyboardMarkup(keyboard))
        else:
            await update.message.reply_text(msg + "Êó†ÊåÅ‰ªì", reply_markup=reply_markup_main)

# --- ÊòæÁ§∫ÊåÅ‰ªìÈÄâÊã©ÁïåÈù¢ ---
async def show_position_selection(query, context, positions):
    user_id = query.from_user.id
    user_states[user_id] = {"step": "select_positions", "positions": positions}
    
    msg = "ËØ∑ÈÄâÊã©Ë¶ÅÁ∫≥ÂÖ•Êú¨Á≥ªÁªüÁÆ°ÁêÜÁöÑÊåÅ‰ªì:\n"
    keyboard = []
    
    for idx, (symbol, pos) in enumerate(positions.items(), 1):
        pos_type = "Â§ö‰ªì" if pos["side"] == "LONG" else "Á©∫‰ªì"
        msg += f"{idx}. {symbol} {pos_type} Êï∞Èáè: {pos['qty']:.4f}\n"
        keyboard.append([InlineKeyboardButton(f"{idx}. {symbol}", callback_data=f"select_position:{symbol}")])
    
    keyboard.append([InlineKeyboardButton("Á°ÆËÆ§ÈÄâÊã©", callback_data="confirm_selection")])
    keyboard.append([InlineKeyboardButton("ÂèñÊ∂à", callback_data="cancel_selection")])
    
    await query.message.reply_text(
        msg,
        reply_markup=InlineKeyboardMarkup(keyboard))
    await query.answer()

# --- button_callback ÂáΩÊï∞Ôºà‰ºòÂåñÊµÅÁ®ãÔºâ---
async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    data_parts = query.data.split(":")
    app = context.application

    # Ëá™Âä®‰∫§ÊòìËÆæÁΩÆÊñπÂºèÈÄâÊã©
    if data_parts[0] == "auto_trade_setting":
        trade_settings["setting_mode"] = data_parts[1]
        save_trade_settings(trade_settings)
        
        if data_parts[1] == "global":
            user_states[user_id] = {"step": "set_global_leverage"}
            await query.edit_message_text("Â∑≤ÈÄâÊã©ÂÖ®Â±ÄËÆæÁΩÆ")
            await query.message.reply_text(
                "ËØ∑ËæìÂÖ•ÂÖ®Â±ÄÊù†ÊùÜÂÄçÊï∞ (1-125):",
                reply_markup=ReplyKeyboardMarkup([["ÂèñÊ∂à"]], resize_keyboard=True))
        elif data_parts[1] == "individual":
            user_states[user_id] = {
                "step": "set_individual_leverage",
                "symbols": [s["symbol"] for s in data["symbols"]],
                "current_index": 0,
                "settings": {}
            }
            symbol = user_states[user_id]["symbols"][0]
            await query.edit_message_text("Â∑≤ÈÄâÊã©ÈÄê‰∏ÄËÆæÁΩÆ")
            await query.message.reply_text(
                f"ËØ∑ËÆæÁΩÆ {symbol} ÁöÑÊù†ÊùÜÂÄçÊï∞ (1-125):",
                reply_markup=ReplyKeyboardMarkup([["ÂèñÊ∂à"]], resize_keyboard=True))

    # ÈùûÁ≥ªÁªüËÆ¢ÂçïÂ§ÑÁêÜ
    elif data_parts[0] == "integrate_existing":
        if data_parts[1] == "all":
            # Áõ¥Êé•‰ΩøÁî®Ê®°ÂùóÁ∫ßÂèòÈáè
            for symbol, pos in existing_positions.items():
                existing_positions[symbol]["system_order"] = True
                existing_positions[symbol]["active"] = True
                positions[symbol] = {
                    "side": pos["side"],
                    "qty": pos["qty"],
                    "entry_price": pos["entry_price"],
                    "system_order": True
                }
                       
            save_existing_positions(existing_positions)
            await query.edit_message_text("ÊâÄÊúâÈùûÊú¨Á≥ªÁªüÊåÅ‰ªìÂ∑≤Á∫≥ÂÖ•Êú¨Á≥ªÁªüÁÆ°ÁêÜ")
            
            # ÂºÄÂêØËá™Âä®‰∫§ÊòìÂπ∂ÊòæÁ§∫ËÆæÁΩÆ
            trade_settings["auto_trade"] = True
            save_trade_settings(trade_settings)
            await show_auto_trade_settings(app, user_id)
        
        elif data_parts[1] == "none":
            # Áî®Êà∑ÈÄâÊã©‰∏çÁ∫≥ÂÖ•Êú¨Á≥ªÁªü
            await query.edit_message_text("ÈùûÊú¨Á≥ªÁªüÊåÅ‰ªìÂ∞Ü‰øùÊåÅÂéüÁä∂Ôºå‰∏ç‰ºöËá™Âä®ËÆæÁΩÆÊ≠¢ÁõàÊ≠¢Êçü")
            
            # ÂºÄÂêØËá™Âä®‰∫§ÊòìÂπ∂ÊòæÁ§∫ËÆæÁΩÆ
            trade_settings["auto_trade"] = True
            save_trade_settings(trade_settings)
            await show_auto_trade_settings(app, user_id)
        
        elif data_parts[1] == "select":
            # Áî®Êà∑ÈÄâÊã©ÈÉ®ÂàÜÁ∫≥ÂÖ•
            await show_position_selection(query, context, existing_positions)

    # ÈÄâÊã©ÂÖ∑‰ΩìÊåÅ‰ªì
    elif data_parts[0] == "select_position":
        symbol = data_parts[1]
        state = user_states.get(user_id, {})
        if "selected_positions" not in state:
            state["selected_positions"] = {}
        
        # ÂàáÊç¢ÈÄâÊã©Áä∂ÊÄÅ
        if symbol in state["selected_positions"]:
            del state["selected_positions"][symbol]
        else:
            state["selected_positions"][symbol] = existing_positions[symbol]
        
        user_states[user_id] = state
        
        # Êõ¥Êñ∞Ê∂àÊÅØÊòæÁ§∫ÈÄâÊã©Áä∂ÊÄÅ
        msg = "Â∑≤ÈÄâÊã©ÊåÅ‰ªì:\n"
        for sym in state["selected_positions"]:
            pos = existing_positions[sym]
            pos_type = "Â§ö‰ªì" if pos["side"] == "LONG" else "Á©∫‰ªì"
            msg += f"- {sym} {pos_type} Êï∞Èáè: {pos['qty']:.4f}\n"
        
        await query.edit_message_text(
            text=msg,
            reply_markup=query.message.reply_markup
        )
        await query.answer()
    
    # Á°ÆËÆ§ÈÄâÊã©
    elif data_parts[0] == "confirm_selection":
        state = user_states.get(user_id, {})
        if "selected_positions" in state:
            for symbol, pos in state["selected_positions"].items():
                # Ê†áËÆ∞‰∏∫Êú¨Á≥ªÁªüËÆ¢Âçï
                existing_positions[symbol]["system_order"] = True
                existing_positions[symbol]["active"] = True
                
                # Ê∑ªÂä†Âà∞positionsÂ≠óÂÖ∏
                positions[symbol] = {
                    "side": pos["side"],
                    "qty": pos["qty"],
                    "entry_price": pos["entry_price"],
                    "system_order": True
                }
            
            save_existing_positions(existing_positions)
            await query.edit_message_text("Â∑≤ÈÄâÊã©ÁöÑÊåÅ‰ªìÂ∑≤Á∫≥ÂÖ•Êú¨Á≥ªÁªüÁÆ°ÁêÜ")
            
            # ÂºÄÂêØËá™Âä®‰∫§ÊòìÂπ∂ÊòæÁ§∫ËÆæÁΩÆ
            trade_settings["auto_trade"] = True
            save_trade_settings(trade_settings)
            await show_auto_trade_settings(app, user_id)
    
    # ÂèñÊ∂àÈÄâÊã©
    elif data_parts[0] == "cancel_selection":
        if user_id in user_states:
            del user_states[user_id]
        await query.edit_message_text("ÊåÅ‰ªìÈÄâÊã©Â∑≤ÂèñÊ∂à")
        await app.bot.send_message(user_id, "ËØ∑‰ΩøÁî®‰∏ãÊñπËèúÂçïÁªßÁª≠Êìç‰ΩúÔºö", reply_markup=reply_markup_main)

    # ÈÄâÊã©Â∏ÅÁßçÁ±ªÂûã
    elif data_parts[0] == "select_type":
        symbol = data_parts[1]
        market_type = data_parts[2]
        data["symbols"].append({"symbol": symbol, "type": market_type})
        with open(DATA_FILE, "w") as f:
            json.dump(data, f)
        await query.edit_message_text(f"Â∑≤Ê∑ªÂä† {symbol} ({market_type})")
        
        keyboard = [
            [InlineKeyboardButton("ÁªßÁª≠Ê∑ªÂä†", callback_data="continue_add:yes")],
            [InlineKeyboardButton("ËøîÂõûËèúÂçï", callback_data="continue_add:no")]
        ]
        await query.message.reply_text(
            "ÊòØÂê¶ÁªßÁª≠Ê∑ªÂä†Â∏ÅÁßçÔºü",
            reply_markup=InlineKeyboardMarkup(keyboard))
        await query.answer()
    
    # ÁªßÁª≠Ê∑ªÂä†Â∏ÅÁßç
    elif data_parts[0] == "continue_add":
        if data_parts[1] == "yes":
            user_states[user_id] = {"step": "add_symbol"}
            await query.message.reply_text("ËØ∑ËæìÂÖ•Â∏ÅÁßçÔºàÂ¶Ç BTCUSDTÔºâÔºöËæìÂÖ•'ÂèñÊ∂à'ÂèØ‰∏≠Êñ≠")
        else:
            user_states[user_id] = {}
            keyboard = [
                [InlineKeyboardButton("Á´ãÂç≥ÂºÄÂêØÁõëÊéß", callback_data="start_monitor:yes")],
                [InlineKeyboardButton("Á®çÂêéÊâãÂä®ÂºÄÂêØ", callback_data="start_monitor:no")]
            ]
            await query.message.reply_text(
                "ÊòØÂê¶Á´ãÂç≥ÂºÄÂêØÁõëÊéßÔºü",
                reply_markup=InlineKeyboardMarkup(keyboard))
        await query.answer()
    
    # ÂºÄÂêØÁõëÊéß
    elif data_parts[0] == "start_monitor":
        if data_parts[1] == "yes":
            data["monitor"] = True
            with open(DATA_FILE, "w") as f:
                json.dump(data, f)
            global monitoring_task
            if not monitoring_task or monitoring_task.done():
                monitoring_task = asyncio.create_task(monitor_task(context.application))
            
            msg = "ÁõëÊéßÂ∑≤ÂºÄÂêØ\nÂΩìÂâçÁõëÊéßÂàóË°®Ôºö\n"
            for s in data["symbols"]:
                try:
                    klines = await get_klines(s["symbol"], s["type"])
                    if klines:
                        _, _, price = calculate_ma(klines)
                        msg += f"{s['symbol']} ({s['type']}): {price:.4f}\n"
                except Exception as e:
                    print(f"Ëé∑Âèñ‰ª∑Ê†ºÂ§±Ë¥•: {e}")
                    msg += f"{s['symbol']} ({s['type']}): Ëé∑Âèñ‰ª∑Ê†ºÂ§±Ë¥•\n"
            
            await query.edit_message_text(msg)
        else:
            await query.edit_message_text("ÊÇ®ÂèØ‰ª•Âú®ËèúÂçï‰∏≠ÊâãÂä®ÂºÄÂêØÁõëÊéß")
        await app.bot.send_message(user_id, "ËØ∑‰ΩøÁî®‰∏ãÊñπËèúÂçïÁªßÁª≠Êìç‰ΩúÔºö", reply_markup=reply_markup_main)
        await query.answer()
    
    # Á°ÆËÆ§‰∫§ÊòìËÆæÁΩÆ
    elif data_parts[0] == "confirm_trade":
        if data_parts[1] == "yes":
            # ÂÖàÊ£ÄÊü•ÈùûÁ≥ªÁªüËÆ¢Âçï
            existing_positions_info = await check_existing_positions(app, user_id)
            
            if existing_positions_info:
                await query.edit_message_text("Ê£ÄÊµãÂà∞ÈùûÊú¨Á≥ªÁªüÊåÅ‰ªìÔºåÊ≠£Âú®Â§ÑÁêÜ...")
                await query.message.reply_text(
                    existing_positions_info["message"],
                    reply_markup=InlineKeyboardMarkup(existing_positions_info["keyboard"]))
            else:
                # Ê≤°ÊúâÈùûÁ≥ªÁªüËÆ¢ÂçïÔºåÁõ¥Êé•ÂºÄÂêØËá™Âä®‰∫§Êòì
                trade_settings["auto_trade"] = True
                save_trade_settings(trade_settings)
                await show_auto_trade_settings(app, user_id)
        else:
            user_states[user_id] = {}
            trade_settings["auto_trade"] = False
            save_trade_settings(trade_settings)
            await query.edit_message_text("Ëá™Âä®‰∫§ÊòìËÆæÁΩÆÂ∑≤ÂèñÊ∂à")
            await app.bot.send_message(user_id, "ËØ∑‰ΩøÁî®‰∏ãÊñπËèúÂçïÁªßÁª≠Êìç‰ΩúÔºö", reply_markup=reply_markup_main)
        await query.answer()

    # Ê∏ÖÁ©∫ÊâÄÊúâÊåÅ‰ªì
    elif data_parts[0] == "close_all":
        if data_parts[1] == "yes":
            try:
                positions_data = await binance_request("GET", "/fapi/v2/positionRisk", None, True)
                if positions_data:
                    for pos in positions_data:
                        if float(pos["positionAmt"]) != 0:
                            symbol = pos["symbol"]
                            side = "SELL" if float(pos["positionAmt"]) > 0 else "BUY"
                            await place_market_order(symbol, side, abs(float(pos["positionAmt"])))
                
                await query.edit_message_text("ÊâÄÊúâÊåÅ‰ªìÂ∑≤Ê∏ÖÁ©∫")
            except Exception as e:
                await query.edit_message_text(f"Ê∏Ö‰ªìÂ§±Ë¥•: {str(e)}")
        else:
            await query.edit_message_text("Â∑≤‰øùÁïôÊåÅ‰ªì")
        
        await app.bot.send_message(user_id, "ËØ∑‰ΩøÁî®‰∏ãÊñπËèúÂçïÁªßÁª≠Êìç‰ΩúÔºö", reply_markup=reply_markup_main)

# --- ÂºÇÊ≠•‰ªªÂä°ÔºöÂÖ≥Èó≠ÊâÄÊúâÊåÅ‰ªì ---
async def close_all_positions(query, context):
    user_id = query.from_user.id
    app = context.application
    
    try:
        positions_data = await binance_request("GET", "/fapi/v2/positionRisk", None, True)
        if positions_data:
            for pos in positions_data:
                if float(pos["positionAmt"]) != 0:
                    symbol = pos["symbol"]
                    side = "SELL" if float(pos["positionAmt"]) > 0 else "BUY"
                    await place_market_order(symbol, side, abs(float(pos["positionAmt"])))
        
        await query.edit_message_text("ÊâÄÊúâÊåÅ‰ªìÂ∑≤Ê∏ÖÁ©∫")
        await app.bot.send_message(user_id, "ËØ∑‰ΩøÁî®‰∏ãÊñπËèúÂçïÁªßÁª≠Êìç‰ΩúÔºö", reply_markup=reply_markup_main)
    except Exception as e:
        await query.edit_message_text(f"Ê∏Ö‰ªìÂ§±Ë¥•: {str(e)}")
        await app.bot.send_message(user_id, "ËØ∑ÈáçËØïÊàñÊâãÂä®Êìç‰Ωú", reply_markup=reply_markup_main)
 
# --- show_status ÂáΩÊï∞Ôºà‰ºòÂåñÊòæÁ§∫Ê†ºÂºèÔºâ---
async def show_status(update):
    msg = f"ÁõëÊéßÁä∂ÊÄÅ: {'ÂºÄÂêØ' if data['monitor'] else 'ÂÖ≥Èó≠'}\n"
    msg += f"Ëá™Âä®‰∫§Êòì: {'ÂºÄÂêØ' if trade_settings['auto_trade'] else 'ÂÖ≥Èó≠'}\n"
    
    if trade_settings["auto_trade"]:
        msg += f"ËÆæÁΩÆÊñπÂºè: {'ÂÖ®Â±ÄËÆæÁΩÆ' if trade_settings['setting_mode'] == 'global' else 'ÈÄê‰∏ÄËÆæÁΩÆ'}\n"
        msg += f"Ê≠¢Áõà: {trade_settings['take_profit']}%\n"
        msg += f"Ê≠¢Êçü: {trade_settings['stop_loss']}%\n"
        
        if trade_settings["setting_mode"] == "global":
            msg += f"ÂÖ®Â±ÄÊù†ÊùÜ: {trade_settings['global_leverage']}x\n"
            msg += f"ÂÖ®Â±ÄÊØèÂçïÈáëÈ¢ù: {trade_settings['global_order_amount']} USDT\n"
        else:
            msg += "Â∏ÅÁßçÁâπÂÆöËÆæÁΩÆ:\n"
            for symbol, settings in trade_settings["individual_settings"].items():
                leverage = settings.get("leverage", trade_settings["global_leverage"])
                order_amount = settings.get("order_amount", trade_settings["global_order_amount"])
                msg += f"- {symbol}: {leverage}x, {order_amount} USDT\n"
    
    if data["symbols"]:
        msg += "\nÁõëÊéßÂàóË°®:\n"
        for s in data["symbols"]:
            try:
                klines = await get_klines(s["symbol"], s["type"])
                if klines:
                    _, _, price = calculate_ma(klines)
                    msg += f"{s['symbol']} ({s['type']}): {price:.4f}\n"
            except:
                msg += f"{s['symbol']} ({s['type']}): Ëé∑ÂèñÂ§±Ë¥•\n"
    
    # Êú¨Á≥ªÁªüÊåÅ‰ªìÔºàÊó†ËÆ∫Ëá™Âä®‰∫§ÊòìÊòØÂê¶ÂºÄÂêØÈÉΩÊòæÁ§∫Ôºâ
    if positions:
        msg += "\nüìä Êú¨Á≥ªÁªüÊåÅ‰ªì:\n"
        for symbol, pos in positions.items():
            pos_type = "Â§ö‰ªì" if pos["side"] == "LONG" else "Á©∫‰ªì"
            # ËÆ°ÁÆóÁõà‰∫è
            profit, profit_percent = await calculate_position_profit(
                symbol, 
                pos["entry_price"], 
                pos["side"], 
                pos["qty"]
            )
            profit_sign = "+" if profit > 0 else ""
            
            msg += (f"{symbol} {pos_type}\n"
                    f"Êï∞Èáè: {pos['qty']:.4f}\n"
                    f"ÂºÄ‰ªì‰ª∑: {pos['entry_price']:.4f}\n"
                    f"Áõà‰∫è: {profit_sign}{profit:.2f} ({profit_sign}{profit_percent:.2f}%)\n")
    
    # ÈùûÊú¨Á≥ªÁªüÊåÅ‰ªìÔºàÊó†ËÆ∫Ëá™Âä®‰∫§ÊòìÊòØÂê¶ÂºÄÂêØÈÉΩÊòæÁ§∫Ôºâ
    non_system_positions = False
    if existing_positions:
        for symbol, pos in existing_positions.items():
            if float(pos["qty"]) > 0 and not pos.get("system_order", False):
                non_system_positions = True
                break
        
        if non_system_positions:
            msg += "\nüìä ÈùûÊú¨Á≥ªÁªüÊåÅ‰ªì:\n"
            for symbol, pos in existing_positions.items():
                # Âè™ÊòæÁ§∫Êú™ËΩ¨ÂÖ•Êú¨Á≥ªÁªüÁöÑÊåÅ‰ªì
                if float(pos["qty"]) > 0 and not pos.get("system_order", False):
                    # Ëé∑ÂèñÂÆûÊó∂Êï∞ÊçÆ
                    realtime_pos = await get_position(symbol)
                    if realtime_pos:
                        # ‰ΩøÁî®ÂÆûÊó∂Êï∞ÊçÆËÆ°ÁÆóÁõà‰∫è
                        profit = realtime_pos["unrealized_profit"]
                        if realtime_pos["entry_price"] > 0:
                            profit_percent = (profit / (realtime_pos["entry_price"] * realtime_pos["qty"])) * 100
                        else:
                            profit_percent = 0
                        profit_sign = "+" if profit > 0 else ""
                        
                        msg += (f"{symbol} {realtime_pos['side']} x{realtime_pos['leverage']}\n"
                                f"Êï∞Èáè: {realtime_pos['qty']:.4f}\n"
                                f"ÂºÄ‰ªì‰ª∑: {realtime_pos['entry_price']:.4f}\n"
                                f"Ê†áËÆ∞‰ª∑: {realtime_pos['mark_price']:.4f}\n"
                                f"Êú™ÂÆûÁé∞Áõà‰∫è: {profit_sign}{profit:.4f} USDT\n"
                                f"Áõà‰∫èÁéá: {profit_sign}{profit_percent:.2f}%\n")
    
    if not positions and not non_system_positions:
        msg += "\nÂΩìÂâçÊó†ÊåÅ‰ªì"
    
    await update.message.reply_text(msg, reply_markup=reply_markup_main)

# --- show_help ÂáΩÊï∞ ---
async def show_help(update):
    help_text = (
        "üìå ÂäüËÉΩËØ¥ÊòéÔºö\n"
        "1. Ê∑ªÂä†Â∏ÅÁßç - Ê∑ªÂä†ÁõëÊéßÁöÑÂ∏ÅÁßç\n"
        "2. Âà†Èô§Â∏ÅÁßç - ‰ªéÁõëÊéßÂàóË°®‰∏≠ÁßªÈô§Â∏ÅÁßç\n"
        "3. ÂºÄÂêØÁõëÊéß - ÂºÄÂßãMA9/MA26ÁõëÊéß\n"
        "4. ÂÅúÊ≠¢ÁõëÊéß - ÂÅúÊ≠¢ÁõëÊéß\n"
        "5. ÂºÄÂêØËá™Âä®‰∫§Êòì - ËÆæÁΩÆÊù†ÊùÜÂíåÈáëÈ¢ùÂêéËá™Âä®‰∫§Êòì\n"
        "6. ÂÖ≥Èó≠Ëá™Âä®‰∫§Êòì - ÂÅúÊ≠¢Ëá™Âä®‰∫§ÊòìÂπ∂ÂèØÈÄâÊã©Ê∏Ö‰ªì\n"
        "7. Êü•ÁúãÁä∂ÊÄÅ - ÊòæÁ§∫ÂΩìÂâçÁõëÊéßÂíåÊåÅ‰ªìÁä∂ÊÄÅ\n"
        "8. Â∏ÆÂä© - ÊòæÁ§∫Ê≠§Â∏ÆÂä©‰ø°ÊÅØ\n\n"
        "üìä ‰ø°Âè∑ËßÑÂàôÔºö\n"
        "- ‰π∞ÂÖ•‰ø°Âè∑: MA9‰∏äÁ©øMA26\n"
        "- ÂçñÂá∫‰ø°Âè∑: MA9‰∏ãÁ©øMA26\n\n"
        "üí° Ëá™Âä®‰∫§ÊòìËÆæÁΩÆÔºö\n"
        "- ÂÖ®Â±ÄËÆæÁΩÆÔºöÊâÄÊúâÂ∏ÅÁßç‰ΩøÁî®Áõ∏ÂêåÁöÑÊù†ÊùÜÂíåÂºÄ‰ªìÈáëÈ¢ù\n"
        "- ÈÄê‰∏ÄËÆæÁΩÆÔºö‰∏∫ÊØè‰∏™Â∏ÅÁßçÂçïÁã¨ËÆæÁΩÆÊù†ÊùÜÂíåÂºÄ‰ªìÈáëÈ¢ù\n"
        "- ÈáëÈ¢ùËÆæÁΩÆÔºöËÆæÁΩÆÁöÑÊòØÂêç‰πâ‰ª∑ÂÄºÔºàËÆ¢ÂçïÊÄª‰ª∑ÂÄºÔºâ\n\n"
        "üí° ÈùûÊú¨Á≥ªÁªüÊåÅ‰ªìÂ§ÑÁêÜÔºö\n"
        "ÂºÄÂêØËá™Âä®‰∫§ÊòìÊó∂ÔºåÂ¶ÇÂèëÁé∞ÈùûÊú¨Á≥ªÁªüÊåÅ‰ªìÔºåÁ≥ªÁªü‰ºöÂºïÂØºÊÇ®ÈÄâÊã©ÊòØÂê¶Â∞ÜËøô‰∫õÊåÅ‰ªìÁ∫≥ÂÖ•Êú¨Á≥ªÁªüÁÆ°ÁêÜ"
    )
    await update.message.reply_text(help_text, reply_markup=reply_markup_main)

# --- refresh_delete_list ÂáΩÊï∞Ôºà‰øÆÂ§çÁä∂ÊÄÅÈóÆÈ¢òÔºâ---
async def refresh_delete_list(update, user_id):
    if not data["symbols"]:
        await update.message.reply_text("Â∑≤Êó†Êõ¥Â§öÂ∏ÅÁßçÂèØÂà†Èô§", reply_markup=reply_markup_main)
        user_states[user_id] = {}
        return
    
    msg = "ËØ∑ÈÄâÊã©Ë¶ÅÂà†Èô§ÁöÑÂ∏ÅÁßçÔºö\n"
    for idx, s in enumerate(data["symbols"], 1):
        msg += f"{idx}. {s['symbol']} ({s['type']})\n"
    
    # ‰ΩøÁî®‰∏¥Êó∂ÈîÆÁõòÔºåÈÅøÂÖçËØØËß¶‰∏ªËèúÂçï
    temp_keyboard = ReplyKeyboardMarkup([["ÂèñÊ∂à"]], resize_keyboard=True)
    user_states[user_id] = {"step": "delete_symbol"}
    await update.message.reply_text(
        msg + "\nËØ∑ËæìÂÖ•ÁºñÂè∑ÁªßÁª≠Âà†Èô§ÔºåÊàñËæìÂÖ•'ÂèñÊ∂à'ËøîÂõû", 
        reply_markup=temp_keyboard)

# --- start ÂáΩÊï∞ ---
async def start(update, context):
    user_id = update.effective_chat.id
    user_states[user_id] = {}
    print(f"Áî®Êà∑ {user_id} ÂêØÂä®‰∫ÜÊú∫Âô®‰∫∫")
    await update.message.reply_text(
        "üöÄ MA‰∫§ÊòìÊú∫Âô®‰∫∫Â∑≤ÂêØÂä®\nËØ∑‰ΩøÁî®‰∏ãÊñπËèúÂçïÊìç‰Ωú:",
        reply_markup=reply_markup_main)

# --- handle_message ÂáΩÊï∞Ôºà‰øÆÂ§çÂà†Èô§Áä∂ÊÄÅÈóÆÈ¢òÔºâ---
async def handle_message(update, context):
    user_id = update.effective_chat.id
    text = update.message.text.strip()
    app = context.application
    
    print(f"Êî∂Âà∞Êù•Ëá™Áî®Êà∑ {user_id} ÁöÑÊ∂àÊÅØ: {text}")
 
    if text.lower() == "ÂèñÊ∂à":
        if user_id in user_states:
            del user_states[user_id]
        await update.message.reply_text("Êìç‰ΩúÂ∑≤ÂèñÊ∂à", reply_markup=reply_markup_main)
        return
 
    state = user_states.get(user_id, {})
    
    # ÂÖ®Â±ÄÊù†ÊùÜËÆæÁΩÆ
    if state.get("step") == "set_global_leverage":
        try:
            leverage = int(text)
            if 1 <= leverage <= 125:
                trade_settings["global_leverage"] = leverage
                save_trade_settings(trade_settings)
                user_states[user_id] = {"step": "set_global_amount"}
                await update.message.reply_text(
                    f"ÂÖ®Â±ÄÊù†ÊùÜËÆæÁΩÆÂÆåÊàê {leverage}x\nËØ∑ËæìÂÖ•ÂÖ®Â±ÄÊØèÂçïÈáëÈ¢ù(USDT):",
                    reply_markup=ReplyKeyboardMarkup([["ÂèñÊ∂à"]], resize_keyboard=True))
            else:
                await update.message.reply_text("Êù†ÊùÜÈúÄÂú®1-125‰πãÈó¥")
        except ValueError:
            await update.message.reply_text("ËØ∑ËæìÂÖ•ÊúâÊïàÊï∞Â≠ó")
    
    # ÂÖ®Â±ÄÈáëÈ¢ùËÆæÁΩÆ
    elif state.get("step") == "set_global_amount":
        try:
            amount = float(text)
            if amount > 0:
                trade_settings["global_order_amount"] = amount
                save_trade_settings(trade_settings)
                user_states[user_id] = {"step": "set_take_profit"}
                await update.message.reply_text(
                    f"ÂÖ®Â±ÄÈáëÈ¢ùËÆæÁΩÆÂÆåÊàê {amount} USDT\nËØ∑ËæìÂÖ•Ê≠¢ÁõàÁôæÂàÜÊØî(0Ë°®Á§∫‰∏çËÆæÁΩÆ):",
                    reply_markup=ReplyKeyboardMarkup([["ÂèñÊ∂à"]], resize_keyboard=True))
            else:
                await update.message.reply_text("ÈáëÈ¢ùÂøÖÈ°ªÂ§ß‰∫é0")
        except ValueError:
            await update.message.reply_text("ËØ∑ËæìÂÖ•ÊúâÊïàÊï∞Â≠ó")
    
    # ÈÄê‰∏ÄËÆæÁΩÆÊù†ÊùÜ
    elif state.get("step") == "set_individual_leverage":
        try:
            leverage = int(text)
            if 1 <= leverage <= 125:
                current_index = state["current_index"]
                symbol = state["symbols"][current_index]
                
                # ‰øùÂ≠òËØ•Â∏ÅÁßçÁöÑÊù†ÊùÜËÆæÁΩÆ
                if symbol not in state["settings"]:
                    state["settings"][symbol] = {}
                state["settings"][symbol]["leverage"] = leverage
                
                # Êõ¥Êñ∞Áä∂ÊÄÅ‰∏∫ËÆæÁΩÆÈáëÈ¢ù
                state["step"] = "set_individual_amount"
                user_states[user_id] = state
                
                await update.message.reply_text(
                    f"{symbol} Êù†ÊùÜËÆæÁΩÆÂÆåÊàê {leverage}x\nËØ∑ËæìÂÖ• {symbol} ÁöÑÂºÄ‰ªìÈáëÈ¢ù(USDT):",
                    reply_markup=ReplyKeyboardMarkup([["ÂèñÊ∂à"]], resize_keyboard=True))
            else:
                await update.message.reply_text("Êù†ÊùÜÈúÄÂú®1-125‰πãÈó¥")
        except ValueError:
            await update.message.reply_text("ËØ∑ËæìÂÖ•ÊúâÊïàÊï∞Â≠ó")
    
    # ÈÄê‰∏ÄËÆæÁΩÆÈáëÈ¢ù
    elif state.get("step") == "set_individual_amount":
        try:
            amount = float(text)
            if amount > 0:
                current_index = state["current_index"]
                symbol = state["symbols"][current_index]
                
                # ‰øùÂ≠òËØ•Â∏ÅÁßçÁöÑÂºÄ‰ªìÈáëÈ¢ù
                state["settings"][symbol]["order_amount"] = amount
                
                # ÁßªÂä®Âà∞‰∏ã‰∏Ä‰∏™Â∏ÅÁßç
                current_index += 1
                state["current_index"] = current_index
                
                if current_index < len(state["symbols"]):
                    next_symbol = state["symbols"][current_index]
                    # Â∞ÜÁä∂ÊÄÅÊîπ‰∏∫ËÆæÁΩÆ‰∏ã‰∏Ä‰∏™Â∏ÅÁßçÁöÑÊù†ÊùÜ
                    state["step"] = "set_individual_leverage"
                    user_states[user_id] = state
                    await update.message.reply_text(
                        f"{symbol} ÂºÄ‰ªìÈáëÈ¢ùËÆæÁΩÆÂÆåÊàê {amount} USDT\nËØ∑ËÆæÁΩÆ {next_symbol} ÁöÑÊù†ÊùÜÂÄçÊï∞ (1-125):",
                        reply_markup=ReplyKeyboardMarkup([["ÂèñÊ∂à"]], resize_keyboard=True))
                else:
                    # ÊâÄÊúâÂ∏ÅÁßçËÆæÁΩÆÂÆåÊàêÔºå‰øùÂ≠òËÆæÁΩÆ
                    trade_settings["individual_settings"] = state["settings"]
                    save_trade_settings(trade_settings)
                    
                    # ËøõÂÖ•Ê≠¢ÁõàÊ≠¢ÊçüËÆæÁΩÆ
                    user_states[user_id] = {"step": "set_take_profit"}
                    await update.message.reply_text(
                        "ÊâÄÊúâÂ∏ÅÁßçËÆæÁΩÆÂÆåÊàêÔºÅ\nËØ∑ËæìÂÖ•Ê≠¢ÁõàÁôæÂàÜÊØî(0Ë°®Á§∫‰∏çËÆæÁΩÆ):",
                        reply_markup=ReplyKeyboardMarkup([["ÂèñÊ∂à"]], resize_keyboard=True))
            else:
                await update.message.reply_text("ÈáëÈ¢ùÂøÖÈ°ªÂ§ß‰∫é0")
        except ValueError:
            await update.message.reply_text("ËØ∑ËæìÂÖ•ÊúâÊïàÊï∞Â≠ó")
    
    # Ê≠¢ÁõàËÆæÁΩÆ
    elif state.get("step") == "set_take_profit":
        try:
            take_profit = float(text)
            if 0 <= take_profit <= 100:
                trade_settings["take_profit"] = take_profit
                save_trade_settings(trade_settings)
                user_states[user_id] = {"step": "set_stop_loss"}
                await update.message.reply_text(
                    f"Ê≠¢ÁõàËÆæÁΩÆÂÆåÊàê {take_profit}%\nËØ∑ËæìÂÖ•Ê≠¢ÊçüÁôæÂàÜÊØî(0Ë°®Á§∫‰∏çËÆæÁΩÆ):",
                    reply_markup=ReplyKeyboardMarkup([["ÂèñÊ∂à"]], resize_keyboard=True))
            else:
                await update.message.reply_text("Ê≠¢ÁõàÈúÄÂú®0-100%‰πãÈó¥")
        except ValueError:
            await update.message.reply_text("ËØ∑ËæìÂÖ•ÊúâÊïàÊï∞Â≠ó")
    
    # Ê≠¢ÊçüËÆæÁΩÆ
    elif state.get("step") == "set_stop_loss":
        try:
            stop_loss = float(text)
            if 0 <= stop_loss <= 100:
                trade_settings["stop_loss"] = stop_loss
                save_trade_settings(trade_settings)
                
                # ÊûÑÂª∫ËÆæÁΩÆ‰ø°ÊÅØ
                setting_info = "‚úÖ Ëá™Âä®‰∫§ÊòìËÆæÁΩÆÂÆåÊàê:\n"
                
                if trade_settings["setting_mode"] == "global":
                    setting_info += f"ÂÖ®Â±ÄËÆæÁΩÆ:\n" \
                                   f"Êù†ÊùÜ: {trade_settings['global_leverage']}x\n" \
                                   f"‰∏ãÂçïÈáëÈ¢ù: {trade_settings['global_order_amount']} USDT\n"
                else:
                    setting_info += "ÈÄê‰∏ÄËÆæÁΩÆ:\n"
                    for symbol, settings in trade_settings["individual_settings"].items():
                        leverage = settings.get("leverage", trade_settings["global_leverage"])
                        order_amount = settings.get("order_amount", trade_settings["global_order_amount"])
                        setting_info += f"{symbol} Êù†ÊùÜ: {leverage}x  ‰∏ãÂçïÈáëÈ¢ù: {order_amount}USDT\n"
                
                setting_info += f"Ê≠¢Áõà: {trade_settings['take_profit']}%\n" \
                               f"Ê≠¢Êçü: {trade_settings['stop_loss']}%\n\n" \
                               "ÊòØÂê¶ÂºÄÂêØËá™Âä®‰∫§ÊòìÔºü"
                
                keyboard = [
                    [InlineKeyboardButton("ÊòØÔºåÂºÄÂêØ‰∫§Êòì", callback_data="confirm_trade:yes")],
                    [InlineKeyboardButton("Âê¶ÔºåÂèñÊ∂àËÆæÁΩÆ", callback_data="confirm_trade:no")]
                ]
                
                await update.message.reply_text(
                    setting_info,
                    reply_markup=InlineKeyboardMarkup(keyboard))
            else:
                await update.message.reply_text("Ê≠¢ÊçüÈúÄÂú®0-100%‰πãÈó¥")
        except ValueError:
            await update.message.reply_text("ËØ∑ËæìÂÖ•ÊúâÊïàÊï∞Â≠ó")
    
    # Âà†Èô§Â∏ÅÁßçÁä∂ÊÄÅÔºà‰øÆÂ§çÈóÆÈ¢òÔºâ
    elif state.get("step") == "delete_symbol":
        try:
            idx = int(text) - 1
            if 0 <= idx < len(data["symbols"]):
                removed = data["symbols"].pop(idx)
                with open(DATA_FILE, "w") as f:
                    json.dump(data, f)
                await update.message.reply_text(f"Â∑≤Âà†Èô§ {removed['symbol']}")
                # Âà∑Êñ∞ÂàóË°®Âπ∂‰øùÊåÅÂà†Èô§Áä∂ÊÄÅ
                await refresh_delete_list(update, user_id)
            else:
                await update.message.reply_text("ÁºñÂè∑Êó†Êïà")
        except ValueError:
            await update.message.reply_text("ËØ∑ËæìÂÖ•Êï∞Â≠óÁºñÂè∑")
    
    elif state.get("step") == "add_symbol":
        keyboard = [
            [InlineKeyboardButton("Áé∞Ë¥ß", callback_data=f"select_type:{text.upper()}:spot")],
            [InlineKeyboardButton("ÂêàÁ∫¶", callback_data=f"select_type:{text.upper()}:contract")]
        ]
        await update.message.reply_text(
            f"ËØ∑ÈÄâÊã© {text.upper()} Á±ªÂûã:",
            reply_markup=InlineKeyboardMarkup(keyboard))
    
    # ‰∏ªËèúÂçïÂëΩ‰ª§Â§ÑÁêÜ
    elif text == "1" or "Ê∑ªÂä†Â∏ÅÁßç" in text:
        user_states[user_id] = {"step": "add_symbol"}
        await update.message.reply_text("ËØ∑ËæìÂÖ•Â∏ÅÁßçÔºàÂ¶Ç BTCUSDTÔºâÔºöËæìÂÖ•'ÂèñÊ∂à'ÂèØ‰∏≠Êñ≠")
    
    elif text == "2" or "Âà†Èô§Â∏ÅÁßç" in text:
        if not data["symbols"]:
            await update.message.reply_text("ÂΩìÂâçÊó†Â∑≤Ê∑ªÂä†Â∏ÅÁßç", reply_markup=reply_markup_main)
        else:
            await refresh_delete_list(update, user_id)
    
    elif text == "3" or "ÂºÄÂêØÁõëÊéß" in text:
        data["monitor"] = True
        with open(DATA_FILE, "w") as f:
            json.dump(data, f)
        global monitoring_task
        if not monitoring_task or monitoring_task.done():
            monitoring_task = asyncio.create_task(monitor_task(app))
        
        msg = "ÁõëÊéßÂ∑≤ÂºÄÂêØ\nÂΩìÂâçÁõëÊéß:\n"
        for s in data["symbols"]:
            try:
                klines = await get_klines(s["symbol"], s["type"])
                if klines:
                    _, _, price = calculate_ma(klines)
                    msg += f"- {s['symbol']} ({s['type']}): {price:.4f}\n"
            except Exception as e:
                print(f"Ëé∑Âèñ‰ª∑Ê†ºÂ§±Ë¥•: {e}")
                msg += f"- {s['symbol']} ({s['type']}): Ëé∑ÂèñÂ§±Ë¥•\n"
        await update.message.reply_text(msg, reply_markup=reply_markup_main)
    
    elif text == "4" or "ÂÅúÊ≠¢ÁõëÊéß" in text:
        data["monitor"] = False
        with open(DATA_FILE, "w") as f:
            json.dump(data, f)
        await update.message.reply_text("ÁõëÊéßÂ∑≤ÂÅúÊ≠¢", reply_markup=reply_markup_main)
    
    elif text == "5" or "ÂºÄÂêØËá™Âä®‰∫§Êòì" in text:
        await handle_auto_trade(update, context, True)
    
    elif text == "6" or "ÂÖ≥Èó≠Ëá™Âä®‰∫§Êòì" in text:
        await handle_auto_trade(update, context, False)
    
    elif text == "7" or "Êü•ÁúãÁä∂ÊÄÅ" in text:
        if user_id in user_states:
            del user_states[user_id]
        await show_status(update)

    elif text == "8" or "Â∏ÆÂä©" in text:
        if user_id in user_states:
            del user_states[user_id]
        await show_help(update)

# --- ‰∏ªÁ®ãÂ∫è ---
if __name__ == "__main__":
    # ÂàõÂª∫Â∫îÁî®
    print("Ê≠£Âú®ÂàõÂª∫Â∫îÁî®...")
    app = ApplicationBuilder().token(TOKEN).build()
    
    # Ê∑ªÂä†Â§ÑÁêÜÂô®
    print("Ê∑ªÂä†ÂëΩ‰ª§Â§ÑÁêÜÂô®...")
    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    app.add_handler(CallbackQueryHandler(button_callback))
    
    # ÂàùÂßãÂåñÊó∂Èó¥ÂêåÊ≠•
    print("ÂàùÂßãÂåñÊó∂Èó¥ÂêåÊ≠•...")
    loop = asyncio.get_event_loop()
    loop.run_until_complete(time_sync.sync_time())
    
    # ÂêØÂä®Êú∫Âô®‰∫∫
    print("MA9/MA26‰∫§ÊòìÊú∫Âô®‰∫∫Â∑≤ÂêØÂä®")
    app.run_polling()
